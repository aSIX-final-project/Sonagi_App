"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.writeXml = exports.writeJson = exports.writeHtml = exports.readXml = exports.readHtml = exports.logWrite = exports.log = exports.generate = void 0;
var _detectIndent = _interopRequireDefault(require("detect-indent"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _nodeHtmlParser = require("node-html-parser");
var _path = _interopRequireDefault(require("path"));
var _picocolors = _interopRequireDefault(require("picocolors"));
var htmlPlugin = _interopRequireWildcard(require("prettier/plugins/html"));
var cssPlugin = _interopRequireWildcard(require("prettier/plugins/postcss"));
var prettier = _interopRequireWildcard(require("prettier/standalone"));
var _sharp = _interopRequireDefault(require("sharp"));
var _tsDedent = require("ts-dedent");
var _xmlFormatter = _interopRequireDefault(require("xml-formatter"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const workingPath = process.env.INIT_CWD ?? process.env.PWD ?? process.cwd();
const parseColor = value => {
  const up = value.toUpperCase().replace(/[^0-9A-F]/g, "");
  const hex = "#" + (up.length === 3 ? up + up : up);
  if (hex.length !== 7) {
    log.error("--background-color value is not a valid hexadecimal color.");
    process.exit(1);
  }
  const rgb = {
    R: (parseInt("" + hex[1] + hex[2], 16) / 255).toPrecision(15),
    G: (parseInt("" + hex[3] + hex[4], 16) / 255).toPrecision(15),
    B: (parseInt("" + hex[5] + hex[6], 16) / 255).toPrecision(15)
  };
  return {
    hex,
    rgb
  };
};
const getStoryboard = ({
  logoHeight,
  logoWidth,
  background: {
    R,
    G,
    B
  }
}) => {
  const frameWidth = 375;
  const frameHeight = 667;
  const logoX = (frameWidth - logoWidth) / 2;
  const logoY = (frameHeight - logoHeight) / 2;
  return (0, _tsDedent.dedent)`
<?xml version="1.0" encoding="UTF-8"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="21701" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <device id="retina4_7" orientation="portrait" appearance="light"/>
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="21678"/>
        <capability name="Safe area layout guides" minToolsVersion="9.0"/>
        <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController modalTransitionStyle="crossDissolve" id="01J-lp-oVM" sceneMemberID="viewController">
                    <view key="view" autoresizesSubviews="NO" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <rect key="frame" x="0.0" y="0.0" width="${frameWidth}" height="${frameHeight}"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView autoresizesSubviews="NO" clipsSubviews="YES" userInteractionEnabled="NO" contentMode="scaleAspectFit" image="BootSplashLogo" translatesAutoresizingMaskIntoConstraints="NO" id="3lX-Ut-9ad">
                                <rect key="frame" x="${logoX}" y="${logoY}" width="${logoWidth}" height="${logoHeight}"/>
                                <accessibility key="accessibilityConfiguration">
                                    <accessibilityTraits key="traits" image="YES" notEnabled="YES"/>
                                </accessibility>
                            </imageView>
                        </subviews>
                        <viewLayoutGuide key="safeArea" id="Bcu-3y-fUS"/>
                        <color key="backgroundColor" red="${R}" green="${G}" blue="${B}" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="3lX-Ut-9ad" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="Fh9-Fy-1nT"/>
                            <constraint firstItem="3lX-Ut-9ad" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="nvB-Ic-PnI"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="0.0" y="0.0"/>
        </scene>
    </scenes>
    <resources>
        <image name="BootSplashLogo" width="${logoWidth}" height="${logoHeight}"/>
    </resources>
</document>
`;
};
const log = exports.log = {
  error: text => console.log(_picocolors.default.red(`❌  ${text}`)),
  text: text => console.log(text),
  title: (emoji, text) => console.log(`\n${emoji}  ${_picocolors.default.underline(_picocolors.default.bold(text))}`),
  warn: text => console.log(_picocolors.default.yellow(`⚠️   ${text}`))
};
const logWrite = (filePath, dimensions) => console.log(`    ${_path.default.relative(workingPath, filePath)}` + (dimensions != null ? ` (${dimensions.width}x${dimensions.height})` : ""));
exports.logWrite = logWrite;
const writeJson = (file, json) => {
  _fsExtra.default.writeFileSync(file, JSON.stringify(json, null, 2) + "\n", "utf-8");
  logWrite(file);
};
exports.writeJson = writeJson;
const readXml = file => {
  const xml = _fsExtra.default.readFileSync(file, "utf-8");
  const {
    indent
  } = (0, _detectIndent.default)(xml);
  const formatOptions = {
    indentation: indent || "    "
  };
  return {
    root: (0, _nodeHtmlParser.parse)(xml),
    formatOptions
  };
};
exports.readXml = readXml;
const writeXml = (file, xml, options) => {
  const formatted = (0, _xmlFormatter.default)(xml, {
    collapseContent: true,
    forceSelfClosingEmptyTag: true,
    indentation: "    ",
    lineSeparator: "\n",
    whiteSpaceAtEndOfSelfclosingTag: true,
    ...options
  });
  _fsExtra.default.writeFileSync(file, formatted + "\n", "utf-8");
  logWrite(file);
};
exports.writeXml = writeXml;
const readHtml = file => {
  const html = _fsExtra.default.readFileSync(file, "utf-8");
  const {
    type,
    amount
  } = (0, _detectIndent.default)(html);
  const formatOptions = {
    useTabs: type === "tab",
    tabWidth: amount || 2
  };
  return {
    root: (0, _nodeHtmlParser.parse)(html),
    formatOptions
  };
};
exports.readHtml = readHtml;
const writeHtml = async (file, html, options) => {
  const formatted = await prettier.format(html, {
    parser: "html",
    plugins: [htmlPlugin, cssPlugin],
    tabWidth: 2,
    useTabs: false,
    ...options
  });
  _fsExtra.default.writeFileSync(file, formatted, "utf-8");
  logWrite(file);
};
exports.writeHtml = writeHtml;
const ensureSupportedFormat = async (name, image) => {
  if (image == null) {
    return;
  }
  const {
    format
  } = await image.metadata();
  if (format !== "png" && format !== "svg") {
    log.error(`${name} image file format (${format}) is not supported`);
    process.exit(1);
  }
};
const getAndroidResPath = (android, {
  brandHeight,
  brandWidth,
  flavor,
  logoHeight,
  logoWidth
}) => {
  const androidResPath = _path.default.resolve(android.sourceDir, android.appName, "src", flavor, "res");
  if (!_fsExtra.default.existsSync(androidResPath)) {
    log.warn(`No ${_path.default.relative(workingPath, androidResPath)} directory found. Skipping Android assets generation…`);
  } else if (logoWidth > 288 || logoHeight > 288) {
    log.warn("Logo size exceeding 288x288dp will be cropped by Android. Skipping Android assets generation…");
  } else if (brandHeight > 80 || brandWidth > 200) {
    log.warn("Brand size exceeding 200x80dp will be cropped by Android. Skipping Android assets generation…");
  } else {
    if (logoWidth > 192 || logoHeight > 192) {
      log.warn(`Logo size exceeds 192x192dp. It might be cropped by Android.`);
    }
    return androidResPath;
  }
};
const getIOSProjectPath = ios => {
  if (ios.xcodeProject == null) {
    log.warn("No Xcode project found. Skipping iOS assets generation…");
    return;
  }
  const iosProjectPath = _path.default.resolve(ios.sourceDir, ios.xcodeProject.name).replace(/\.(xcodeproj|xcworkspace)$/, "");
  if (!_fsExtra.default.existsSync(iosProjectPath)) {
    log.warn(`No ${_path.default.relative(workingPath, iosProjectPath)} directory found. Skipping iOS assets generation…`);
  } else {
    return iosProjectPath;
  }
};
const getHtmlTemplatePath = html => {
  const htmlTemplatePath = _path.default.resolve(workingPath, html);
  if (!_fsExtra.default.existsSync(htmlTemplatePath)) {
    log.warn(`No ${_path.default.relative(workingPath, htmlTemplatePath)} file found. Skipping HTML + CSS generation…`);
  } else {
    return htmlTemplatePath;
  }
};
const requireAddon = () => {
  try {
    // eslint-disable-next-line
    return require("./addon");
  } catch {
    return;
  }
};
const generate = async ([argsLogo], {
  project: {
    android,
    ios
  }
}, {
  platforms,
  html,
  flavor,
  licenseKey,
  ...args
}) => {
  const [nodeStringVersion = ""] = process.versions.node.split(".");
  const nodeVersion = parseInt(nodeStringVersion, 10);
  if (!isNaN(nodeVersion) && nodeVersion < 18) {
    log.error("Requires Node 18 (or higher)");
    process.exit(1);
  }
  if (argsLogo == null) {
    log.error("Missing required argument 'logo'");
    process.exit(1);
  }
  const logoPath = _path.default.resolve(workingPath, argsLogo);
  const darkLogoPath = args.darkLogo != null ? _path.default.resolve(workingPath, args.darkLogo) : undefined;
  const brandPath = args.brand != null ? _path.default.resolve(workingPath, args.brand) : undefined;
  const darkBrandPath = args.darkBrand != null ? _path.default.resolve(workingPath, args.darkBrand) : undefined;
  const assetsOutputPath = args.assetsOutput != null ? _path.default.resolve(workingPath, args.assetsOutput) : undefined;
  const logo = (0, _sharp.default)(logoPath);
  const darkLogo = darkLogoPath != null ? (0, _sharp.default)(darkLogoPath) : undefined;
  const brand = brandPath != null ? (0, _sharp.default)(brandPath) : undefined;
  const darkBrand = darkBrandPath != null ? (0, _sharp.default)(darkBrandPath) : undefined;
  const background = parseColor(args.background);
  const logoWidth = args.logoWidth - args.logoWidth % 2;
  const brandWidth = args.brandWidth - args.brandWidth % 2;
  const darkBackground = args.darkBackground != null ? parseColor(args.darkBackground) : undefined;
  const executeAddon = brand != null || darkBackground != null || darkLogo != null || darkBrand != null;
  if (licenseKey != null && !executeAddon) {
    log.warn(`You specified a license key but none of the options that requires it.`);
  }
  if (licenseKey == null && executeAddon) {
    const options = [brand != null ? "brand" : "", darkBackground != null ? "dark-background" : "", darkLogo != null ? "dark-logo" : "", darkBrand != null ? "dark-brand" : ""].filter(option => option !== "").map(option => `--${option}`).join(", ");
    log.error(`You need to specify a license key in order to use ${options}.`);
    process.exit(1);
  }
  if (brand == null && darkBrand != null) {
    log.error("--dark-brand option couldn't be used without --brand.");
    process.exit(1);
  }
  await ensureSupportedFormat("Logo", logo);
  await ensureSupportedFormat("Dark logo", darkLogo);
  await ensureSupportedFormat("Brand", brand);
  await ensureSupportedFormat("Dark brand", darkBrand);
  const logoHeight = await logo.clone().resize(logoWidth).toBuffer().then(buffer => (0, _sharp.default)(buffer).metadata()).then(({
    height = 0
  }) => Math.round(height));
  const brandHeight = (await brand?.clone().resize(brandWidth).toBuffer().then(buffer => (0, _sharp.default)(buffer).metadata()).then(({
    height = 0
  }) => Math.round(height))) ?? 0;
  if (logoWidth < args.logoWidth) {
    log.warn(`Logo width must be a multiple of 2. It has been rounded to ${logoWidth}dp.`);
  }
  if (brandWidth < args.brandWidth) {
    log.warn(`Brand width must be a multiple of 2. It has been rounded to ${brandWidth}dp.`);
  }
  const androidResPath = platforms.includes("android") && android != null ? getAndroidResPath(android, {
    brandHeight,
    brandWidth,
    flavor,
    logoHeight,
    logoWidth
  }) : undefined;
  const iosProjectPath = platforms.includes("ios") && ios != null ? getIOSProjectPath(ios) : undefined;
  const htmlTemplatePath = platforms.includes("web") ? getHtmlTemplatePath(html) : undefined;
  if (androidResPath != null) {
    log.title("🤖", "Android");
    const valuesPath = _path.default.resolve(androidResPath, "values");
    _fsExtra.default.ensureDirSync(valuesPath);
    const colorsXmlPath = _path.default.resolve(valuesPath, "colors.xml");
    const colorsXmlEntry = `<color name="bootsplash_background">${background.hex}</color>`;
    if (_fsExtra.default.existsSync(colorsXmlPath)) {
      const {
        root,
        formatOptions
      } = readXml(colorsXmlPath);
      const nextColor = (0, _nodeHtmlParser.parse)(colorsXmlEntry);
      const prevColor = root.querySelector('color[name="bootsplash_background"]');
      if (prevColor != null) {
        prevColor.replaceWith(nextColor);
      } else {
        root.querySelector("resources")?.appendChild(nextColor);
      }
      writeXml(colorsXmlPath, root.toString(), formatOptions);
    } else {
      writeXml(colorsXmlPath, `<resources>${colorsXmlEntry}</resources>`);
    }
    await Promise.all([{
      ratio: 1,
      suffix: "mdpi"
    }, {
      ratio: 1.5,
      suffix: "hdpi"
    }, {
      ratio: 2,
      suffix: "xhdpi"
    }, {
      ratio: 3,
      suffix: "xxhdpi"
    }, {
      ratio: 4,
      suffix: "xxxhdpi"
    }].map(({
      ratio,
      suffix
    }) => {
      const drawableDirPath = _path.default.resolve(androidResPath, `drawable-${suffix}`);
      _fsExtra.default.ensureDirSync(drawableDirPath);

      // https://developer.android.com/develop/ui/views/launch/splash-screen#dimensions
      const canvasSize = 288 * ratio;

      // https://sharp.pixelplumbing.com/api-constructor
      const canvas = (0, _sharp.default)({
        create: {
          width: canvasSize,
          height: canvasSize,
          channels: 4,
          background: {
            r: 255,
            g: 255,
            b: 255,
            alpha: 0
          }
        }
      });
      const filePath = _path.default.resolve(drawableDirPath, "bootsplash_logo.png");
      return logo.clone().resize(logoWidth * ratio).toBuffer().then(input => canvas.composite([{
        input
      }]).png({
        quality: 100
      }).toFile(filePath)).then(() => {
        logWrite(filePath, {
          width: canvasSize,
          height: canvasSize
        });
      });
    }));
  }
  if (iosProjectPath != null) {
    log.title("🍏", "iOS");
    const storyboardPath = _path.default.resolve(iosProjectPath, "BootSplash.storyboard");
    writeXml(storyboardPath, getStoryboard({
      logoHeight,
      logoWidth,
      background: background.rgb
    }), {
      whiteSpaceAtEndOfSelfclosingTag: false
    });
    const imageSetPath = _path.default.resolve(iosProjectPath, "Images.xcassets", "BootSplashLogo.imageset");
    _fsExtra.default.ensureDirSync(imageSetPath);
    writeJson(_path.default.resolve(imageSetPath, "Contents.json"), {
      images: [{
        idiom: "universal",
        filename: "bootsplash_logo.png",
        scale: "1x"
      }, {
        idiom: "universal",
        filename: "bootsplash_logo@2x.png",
        scale: "2x"
      }, {
        idiom: "universal",
        filename: "bootsplash_logo@3x.png",
        scale: "3x"
      }],
      info: {
        author: "xcode",
        version: 1
      }
    });
    await Promise.all([{
      ratio: 1,
      suffix: ""
    }, {
      ratio: 2,
      suffix: "@2x"
    }, {
      ratio: 3,
      suffix: "@3x"
    }].map(({
      ratio,
      suffix
    }) => {
      const filePath = _path.default.resolve(imageSetPath, `bootsplash_logo${suffix}.png`);
      return logo.clone().resize(logoWidth * ratio).png({
        quality: 100
      }).toFile(filePath).then(({
        width,
        height
      }) => {
        logWrite(filePath, {
          width,
          height
        });
      });
    }));
  }
  if (htmlTemplatePath != null) {
    log.title("🌐", "Web");
    const {
      root,
      formatOptions
    } = readHtml(htmlTemplatePath);
    const {
      format
    } = await logo.metadata();
    const prevStyle = root.querySelector("#bootsplash-style");
    const base64 = (format === "svg" ? _fsExtra.default.readFileSync(logoPath) : await logo.clone().resize(Math.round(logoWidth * 2)).png({
      quality: 100
    }).toBuffer()).toString("base64");
    const dataURI = `data:image/${format ? "svg+xml" : "png"};base64,${base64}`;
    const nextStyle = (0, _nodeHtmlParser.parse)((0, _tsDedent.dedent)`
      <style id="bootsplash-style">
        #bootsplash {
          position: absolute;
          top: 0;
          bottom: 0;
          left: 0;
          right: 0;
          overflow: hidden;
          display: flex;
          justify-content: center;
          align-items: center;
          background-color: ${background.hex};
        }
        #bootsplash-logo {
          content: url("${dataURI}");
          width: ${logoWidth}px;
          height: ${logoHeight}px;
        }
      </style>
    `);
    if (prevStyle != null) {
      prevStyle.replaceWith(nextStyle);
    } else {
      root.querySelector("head")?.appendChild(nextStyle);
    }
    const prevDiv = root.querySelector("#bootsplash");
    const nextDiv = (0, _nodeHtmlParser.parse)((0, _tsDedent.dedent)`
      <div id="bootsplash">
        <div id="bootsplash-logo"></div>
      </div>
    `);
    if (prevDiv != null) {
      prevDiv.replaceWith(nextDiv);
    } else {
      root.querySelector("body")?.appendChild(nextDiv);
    }
    await writeHtml(htmlTemplatePath, root.toString(), formatOptions);
  }
  if (assetsOutputPath != null) {
    log.title("📄", "Assets");
    _fsExtra.default.ensureDirSync(assetsOutputPath);
    writeJson(_path.default.resolve(assetsOutputPath, "bootsplash_manifest.json"), {
      background: background.hex,
      logo: {
        width: logoWidth,
        height: logoHeight
      }
    });
    await Promise.all([{
      ratio: 1,
      suffix: ""
    }, {
      ratio: 1.5,
      suffix: "@1,5x"
    }, {
      ratio: 2,
      suffix: "@2x"
    }, {
      ratio: 3,
      suffix: "@3x"
    }, {
      ratio: 4,
      suffix: "@4x"
    }].map(({
      ratio,
      suffix
    }) => {
      const filePath = _path.default.resolve(assetsOutputPath, `bootsplash_logo${suffix}.png`);
      return logo.clone().resize(Math.round(logoWidth * ratio)).png({
        quality: 100
      }).toFile(filePath).then(({
        width,
        height
      }) => {
        logWrite(filePath, {
          width,
          height
        });
      });
    }));
  }
  if (licenseKey != null && executeAddon) {
    const addon = requireAddon();
    await addon?.execute({
      licenseKey,
      androidResPath,
      iosProjectPath,
      htmlTemplatePath,
      assetsOutputPath,
      logoHeight,
      logoWidth,
      brandHeight,
      brandWidth,
      logoPath,
      darkLogoPath,
      brandPath,
      darkBrandPath,
      background,
      logo,
      brand,
      darkBackground,
      darkLogo,
      darkBrand
    });
  } else {
    log.text(`
${_picocolors.default.blue("┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓")}
${_picocolors.default.blue("┃")}  🔑  ${_picocolors.default.bold("Get a license key for brand image / dark mode support")}  ${_picocolors.default.blue("┃")}
${_picocolors.default.blue("┃")}      ${_picocolors.default.underline("https://zoontek.gumroad.com/l/bootsplash-generator")}     ${_picocolors.default.blue("┃")}
${_picocolors.default.blue("┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛")}`);
  }
  log.text(`\n💖  Thanks for using ${_picocolors.default.underline("react-native-bootsplash")}`);
};
exports.generate = generate;
//# sourceMappingURL=generate.js.map